
import logging
import json
from itertools import combinations
from abc import ABC, abstractmethod
import networkx as nx

_logger = logging.getLogger(__package__)


class PriorKnowledge:

    def __init__(self, n_variables):
        # n_variables
        self._n_variables = n_variables
        # edges
        self._edges = set()
        # noedges
        self._noedges = set()
        # paths
        self._paths = set()
        # nopaths
        self._nopaths = set()
        # exogenous_variables
        self._exogenous_variables = set()
        # sink_variables
        self._sink_variables = set()

    @property
    def n_variables(self):
        return self._n_variables

    @staticmethod
    def _reorder_edge(edge):
        return tuple(sorted(list(edge)))

    @staticmethod
    def _reverse_edge(edge):
        return edge[1], edge[0]

    def add_noedge_rule(self, edge):
        self._noedges.add(self._reorder_edge(edge))
        self._nopaths.add(edge)
        self._nopaths.add(self._reverse_edge(edge))

    def add_edge_rule(self, edge):
        self._edges.add(self._reorder_edge(edge))
        self._paths.add(edge)
        self._paths.add(self._reverse_edge(edge))

    def add_nopath_rule(self, edge):
        self._noedges.add(self._reorder_edge(edge))
        self._nopaths.add(edge)

    def add_path_rule(self, edge):
        self._edges.add(self._reorder_edge(edge))
        self._paths.add(edge)

    def add_exogenous_variable(self, node):
        self._exogenous_variables.add(node)

    def add_sink_variable(self, node):
        self._sink_variables.add(node)


class KnowledgeGenerator(ABC):

    def __init__(self):
        pass


class ImportDAG(KnowledgeGenerator):
    """Import DAGs generated by other logdag results"""

    def __init__(self, args):
        super().__init__()
        raise NotImplementedError


class RuleBasedPruning(KnowledgeGenerator, ABC):

    def __init__(self):
        super().__init__()
        pass

    @staticmethod
    def _load_graph(fp):
        with open(fp, 'r', encoding='utf-8') as f:
            js = json.load(f)
        return nx.node_link_graph(js)

    @abstractmethod
    def _is_adjacent(self, evdef1, evdef2):
        raise NotImplementedError

    def update(self, pk, evmap):
        for node1, node2 in combinations(range(pk.n_variables), 2):
            evdef1, evdef2 = [evmap.evdef(n) for n in (node1, node2)]
            # prune edges that are not topologically adjacent
            if not self._is_adjacent(evdef1, evdef2):
                pk.add_noedge_rule((node1, node2))
        return pk


class Topology(RuleBasedPruning):

    def __init__(self, topology_fp):
        super().__init__()
        self._topology = self._load_graph(topology_fp)

    def _is_adjacent(self, evdef1, evdef2):
        if evdef1.host == evdef2.host:
            return True
        elif self._topology.has_edge(evdef1.host, evdef2.host):
            return True
        else:
            return False


class LayeredTopology(RuleBasedPruning):
    _default_layer = "other"

    def __init__(self, d_topology_fp, d_rule):
        super().__init__()
        self._topology = self._load_graphs(d_topology_fp)
        self._d_rule = d_rule

    @classmethod
    def _load_graphs(cls, d_fp):
        topo = {}
        for name, fp in d_fp.items():
            try:
                topo[name] = cls._load_graph(fp)
            except IOError:
                msg = "failed to load {0} for layer {1}".format(name, fp)
                _logger.warning(msg)
                topo[name] = nx.Graph()
        return topo

    def _get_layer(self, evdef):
        if evdef.group in self._d_rule:
            return self._d_rule[evdef.group]
        else:
            return self._default_layer

    def _is_adjacent(self, evdef1, evdef2):
        # same host
        if evdef1.host == evdef2.host:
            return True

        # connection on a layer of at least one end node
        layer1 = self._get_layer(evdef1)
        layer2 = self._get_layer(evdef2)
        for layer in (layer1, layer2):
            if layer in self._topology:
                net = self._topology[layer]
                if net.has_edge(evdef1.host, evdef2.host):
                    return True
        else:
            return False
