
import logging
import json
from itertools import combinations, permutations
from abc import ABC, abstractmethod
import networkx as nx

_logger = logging.getLogger(__package__)


class PriorKnowledge:

    def __init__(self, node_ids):
        self._node_ids = node_ids
        # edges
        self._edges = set()
        # noedges
        self._noedges = set()
        # paths
        self._paths = set()
        # nopaths
        self._nopaths = set()
        # exogenous_variables
        self._exogenous_variables = set()
        # sink_variables
        self._sink_variables = set()

    @property
    def node_ids(self):
        return self._node_ids

    @staticmethod
    def _reorder_edge(edge):
        return tuple(sorted(list(edge)))

    @staticmethod
    def _reverse_edge(edge):
        return edge[1], edge[0]

    def add_noedge_rule(self, edge):
        self._noedges.add(self._reorder_edge(edge))
        self._nopaths.add(edge)
        self._nopaths.add(self._reverse_edge(edge))

    def add_edge_rule(self, edge):
        self._edges.add(self._reorder_edge(edge))
        self._paths.add(edge)
        self._paths.add(self._reverse_edge(edge))

    def add_nopath_rule(self, edge):
        self._noedges.add(self._reorder_edge(edge))
        self._nopaths.add(edge)

    def add_path_rule(self, edge):
        self._edges.add(self._reorder_edge(edge))
        self._paths.add(edge)

    def add_exogenous_variable(self, node):
        self._exogenous_variables.add(node)

    def add_sink_variable(self, node):
        self._sink_variables.add(node)

    def is_edge(self, edge):
        return self._reorder_edge(edge) in self._edges

    def is_noedge(self, edge):
        return self._reorder_edge(edge) in self._noedges

    def is_path(self, edge):
        return edge in self._paths

    def is_nopath(self, edge):
        return edge in self._nopaths

    def is_exogenous_variable(self, node):
        return node in self._exogenous_variables

    def is_sink_variable(self, node):
        return node in self._sink_variables

    def pruned_initial_skeleton(self):
        # make initial graph for skeleton estimation methods
        # this is pruning-based approach: only considering no-edge rules
        # currently designed for python pcalg library and cnsm2020
        g = nx.Graph()
        g.add_nodes_from(self._node_ids)
        for i, j in combinations(self._node_ids, 2):
            if (i, j) not in self._noedges:
                g.add_edge(i, j)
        return g

    def lingam_prior_knowledge(self, node_ids=None):
        from lingam.utils import make_prior_knowledge
        if node_ids is None:
            kwargs = {"n_variables": len(self._node_ids),
                      "exogenous_variables": self._exogenous_variables,
                      "sink_variables": self._sink_variables,
                      "paths": self._paths,
                      "no_paths": self._nopaths}
        else:
            possible_paths = set(permutations(node_ids, 2))
            exv = set(node_ids) & self._exogenous_variables
            siv = set(node_ids) & self._sink_variables
            paths = possible_paths & self._paths
            nopaths = possible_paths & self._nopaths
            kwargs = {"n_variables": len(node_ids),
                      "exogenous_variables": exv,
                      "sink_variables": siv,
                      "paths": paths,
                      "no_paths": nopaths}
        return make_prior_knowledge(**kwargs)


class KnowledgeGenerator(ABC):

    def __init__(self):
        pass


class ImportDAG(KnowledgeGenerator):
    """Import DAGs generated by other logdag results.

    4 rules:
        prune: Prune edge candidates that have
            no corresponding (or reversed) edges in the imported DAG.
        force: Force edge candidates exist if there are
            corresponding (or reversed) edges in the imported DAG.
        prune+force: Use both prune and force.
        prune-unconnected: Prune edge canndidates
            that have no connectivity (or reachability)
            in the imported DAG.

    """

    def __init__(self, args, rule="prune", allow_reverse=True):
        super().__init__()

        from . import arguments
        from . import showdag
        self._conf, self._dt_range, self._area = args
        src_conf_fn = self._conf["prior_knowledge"]["import_config"]
        self._src_conf = arguments.open_logdag_config(src_conf_fn)
        self._rule = rule
        self._allow_reverse = allow_reverse

        try:
            self._ldag = showdag.LogDAG((self._src_conf, self._dt_range,
                                         self._area))
            self._ldag.load()
            self._src_ugraph = self._ldag.graph.to_undirected()
        except IOError:
            raise IOError("failed to import existing DAG :"
                          "no corresponding results?")

    def _update_edge_prune(self, pk, evmap, node1, node2):
        evdef1 = evmap.evdef(node1)
        evdef2 = evmap.evdef(node2)
        if not self._ldag.has_edge(evdef1, evdef2,
                                   allow_reverse=self._allow_reverse):
            pk.add_noedge_rule((node1, node2))
        return pk

    def _update_edge_force(self, pk, evmap, node1, node2):
        evdef1 = evmap.evdef(node1)
        evdef2 = evmap.evdef(node2)
        if self._ldag.has_edge(evdef1, evdef2, self._allow_reverse):
            pk.add_edge_rule((node1, node2))
        return pk

    def _update_edge_prune_force(self, pk, evmap, node1, node2):
        evdef1 = evmap.evdef(node1)
        evdef2 = evmap.evdef(node2)
        if self._ldag.has_edge(evdef1, evdef2, self._allow_reverse):
            pk.add_edge_rule((node1, node2))
        return pk

    def _update_edge_prune_unconnected(self, pk, evmap, node1, node2):
        evdef1 = evmap.evdef(node1)
        evdef2 = evmap.evdef(node2)
        src_node1, _ = self._ldag.evdef2node(evdef1, self._src_ugraph)
        src_node2, _ = self._ldag.evdef2node(evdef2, self._src_ugraph)
        if not self._src_ugraph.has_path(src_node1, src_node2):
            pk.add_noedge_rule((node1, node2))

    def update(self, pk, evmap):
        if self._rule == "prune":
            method = self._update_edge_prune
        elif self._rule == "force":
            method = self._update_edge_force
        elif self._rule == "prune+force":
            method = self._update_edge_prune_force
        elif self._rule == "prune-unconnected":
            method = self._update_edge_prune_unconnected
        else:
            raise ValueError

        for node1, node2 in combinations(pk.node_ids, 2):
            args = [pk, evmap, node1, node2]
            pk = method(*args)
        return pk


class RuleBasedPruning(KnowledgeGenerator, ABC):

    def __init__(self):
        super().__init__()
        pass

    @staticmethod
    def _load_graph(fp):
        with open(fp, 'r', encoding='utf-8') as f:
            js = json.load(f)
        return nx.node_link_graph(js)

    @abstractmethod
    def _is_adjacent(self, evdef1, evdef2):
        raise NotImplementedError

    def update(self, pk, evmap):
        for node1, node2 in combinations(pk.node_ids, 2):
            evdef1, evdef2 = [evmap.evdef(n) for n in (node1, node2)]
            # prune edges that are not topologically adjacent
            if not self._is_adjacent(evdef1, evdef2):
                pk.add_noedge_rule((node1, node2))
        return pk


class Topology(RuleBasedPruning):

    def __init__(self, topology_fp):
        super().__init__()
        self._topology = self._load_graph(topology_fp)

    def _is_adjacent(self, evdef1, evdef2):
        if evdef1.host == evdef2.host:
            return True
        elif self._topology.has_edge(evdef1.host, evdef2.host):
            return True
        else:
            return False


class LayeredTopology(RuleBasedPruning):
    _default_layer = "other"

    def __init__(self, d_topology_fp, d_rule):
        super().__init__()
        self._topology = self._load_graphs(d_topology_fp)
        self._d_rule = d_rule

    @classmethod
    def _load_graphs(cls, d_fp):
        topo = {}
        for name, fp in d_fp.items():
            try:
                topo[name] = cls._load_graph(fp)
            except IOError:
                msg = "failed to load {0} for layer {1}".format(name, fp)
                _logger.warning(msg)
                topo[name] = nx.Graph()
        return topo

    def _get_layers(self, evdef):
        s_layer = set()
        for group in evdef.groups:
            if group in self._d_rule:
                s_layer.add(self._d_rule[group])
        if len(s_layer) == 0:
            return {self._default_layer}
        else:
            return s_layer

#    def _get_layer(self, evdef):
#        if evdef.group in self._d_rule:
#            return self._d_rule[evdef.group]
#        else:
#            return self._default_layer

    def _is_adjacent(self, evdef1, evdef2):
        # same host
        if evdef1.host == evdef2.host:
            return True

        # allow one intermediate variable (node)
        # -> connection on a layer of at least one end node
        # see cnsm2020 paper
        # now extended to support multiple tags for 1 tpl

        # layer1 = self._get_layer(evdef1)
        # layer2 = self._get_layer(evdef2)
        # for layer in (layer1, layer2):
        #     if layer in self._topology:
        #         net = self._topology[layer]
        #         if net.has_edge(evdef1.host, evdef2.host):
        #             return True
        # else:
        #     return False

        for layer in self._get_layers(evdef1) | self._get_layers(evdef2):
            if layer in self._topology:
                net = self._topology[layer]
                if net.has_edge(evdef1.host, evdef2.host):
                    return True
        else:
            return False


class HostIndependent(RuleBasedPruning):
    # no edges between events on different devices

    def _is_adjacent(self, evdef1, evdef2):
        return evdef1.host == evdef2.host


class AdditionalSource(RuleBasedPruning):
    # no edges between nodes of additional sources

    @staticmethod
    def _is_additional(evdef):
        from . import log2event
        return evdef.source in (log2event.SRCCLS_SNMP, )

    def _is_adjacent(self, evdef1, evdef2):
        return not (self._is_additional(evdef1) and
                    self._is_additional(evdef2))


def init_prior_knowledge(conf, args, evmap):
    from amulog import config
    methods = config.getlist(conf, "prior_knowledge", "methods")
    if len(methods) == 0:
        return None

    node_ids = evmap.eids()
    pk = PriorKnowledge(node_ids)
    for method in methods:
        if method == "import":
            rule = conf.get("prior_knowledge", "import_apply_rule")
            allow_reverse = conf.getboolean("prior_knowledge",
                                            "import_allow_reverse")
            pk = ImportDAG(args, rule, allow_reverse).update(pk, evmap)
        elif method == "topology":
            fp = conf.get("prior_knowledge", "single_network_file")
            pk = Topology(fp).update(pk, evmap)
        elif method == "multi-topology":
            d_fp = {}
            files = config.getlist(conf, "prior_knowledge",
                                   "multi_network_file")
            for group, fp in [s.split(":") for s in files]:
                d_fp[group] = fp
            rulestr = config.getlist(conf, "prior_knowledge",
                                     "multi_network_group")
            d_rule = {}
            for rule in rulestr:
                group, layer = rule.split(":")
                d_rule[group] = layer
            pk = LayeredTopology(d_fp, d_rule).update(pk, evmap)
        elif method == "independent":
            pk = HostIndependent().update(pk, evmap)
        elif method == "additional-source":
            pk = AdditionalSource().update(pk, evmap)
        else:
            raise NotImplementedError("invalid method name {0}".format(method))
    return pk
